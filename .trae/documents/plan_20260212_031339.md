I will switch the mapping mechanism back to using `accountId` as the primary key for timer synchronization and active timer queries, treating it as a user token.

### 1. Update Inngest Sync Logic

**File**: `apps/api/src/inngest/sync-active-timers.ts`

*   **Group by AccountId**: Revert the grouping logic to strictly use `entry.runningFor` (which is the `accountId`).
*   **Cache Key**: Store timers in Redis using the `accountId` as the key (e.g., `clockwork:timers:<accountId>`).
*   **Note**: We will still keep the `resolveTimerAuthors` call to enrich user data (avatar, display name) for the frontend, but it won't be used for grouping anymore.

### 2. Update Active Timers Endpoint

**File**: `apps/api/api/timers/active.ts`

*   **Query by AccountId**: Simplify the query parameter handling to prioritize `accountId`. The `displayName` parameter will be removed or made secondary/deprecated.

### 3. Update Client API

**File**: `apps/tauri/src/lib/api-client.ts`

*   **Fetch by AccountId**: Update `fetchActiveTimers` to accept and send `accountId` as the query parameter.

### 4. Verify Resolve Endpoint (No Change Needed)

**File**: `apps/api/api/users/resolve.ts`

*   This endpoint already returns `accountId`, so the client can continue using it to "login" (resolve email -> accountId) and then use that `accountId` for subsequent timer queries.

This approach ensures robust mapping using the unique `accountId` provided by Jira/Clockwork.
